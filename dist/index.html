<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./style.css" />
    <title>Koinos Contract</title>
  </head>

  <body>
    <div id="app">
      <div id="header">
        <h1>Contract</h1>
        <button @click="connectKondor()">Connect kondor</button>
      </div>
      <div class="container">
        <div class="menu">
          <div v-for="fn in contractFunctions" :key="fn.name">
            <button @click="openFunction(fn.name)">{{fn.prettyName}}</button>
          </div>
        </div>
        <div class="fn-data">
          <h2>{{contractFunction?.prettyName}}</h2>
          <div class="fn-description">{{contractFunction?.description}}</div>
          <proto-form
            v-if="contractFunction && contractFunction.protobufType"
            :protobuftype="contractFunction.protobufType"
            :serializer="contract.serializer"
            reference="protoMessage"
            ref="protoMessage"
          ></proto-form>
          <button
            v-if="contractFunction && contractFunction.readOnly"
            @click="callReadFunction()"
            class="bl"
          >
            Read
            <div v-if="waitingResponse" class="loader"></div>
          </button>
          <button
            v-if="contractFunction && !contractFunction.readOnly"
            @click="callWriteFunction()"
          >
            Send <span v-if="waitingResponse" class="loader"></span>
          </button>
          <div
            class="results"
            v-if="results && contractFunction && contractFunction.readOnly"
          >
            {{results}}
          </div>
        </div>
      </div>
    </div>
  </body>
  <script src="js/kondor.min.js"></script>
  <script src="js/koinos.min.js"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script type="module">
    import { ProtoForm, prettyName } from "./js/protoForm.js";

    const { createApp } = Vue;
    let defaultKoinosProvider = "https://api.koinos.io";
    const mkwWalletConnectorUrl =
      "https://mykw.vercel.app/embed/wallet-connector";
    let mkw;

    const app = createApp({
      data() {
        return {
          accounts: null,
          contract: null,
          contractFunction: null,
          contractFunctions: [],
          inputContractId: "",
          results: "",
          waitingResponse: false,
        };
      },

      mounted() {
        this.loadContract();
        // mkw = new MyKoinosWallet(mkwWalletConnectorUrl);
        // mkw.connect();
      },

      methods: {
        /**
         * Connect wallet
         */
        async connectKondor() {
          console.log("Connecting kondor...");
          this.accounts = await kondor.getAccounts();
          console.log("Kondor connected");
        },

        /**
         * Load the contract class
         */
        async loadContract() {
          //if (!this.accounts) await this.connectKondor();
          const provider = new Provider(["https://api.koinos.io"]);
          //const userAddress = this.accounts[0].address;

          this.contract = new Contract({
            id: "1EwJUW4BFbA4EGmSyB9bgdhB3gk2f3shRN",
            provider,
            //signer: kondor.getSigner(userAddress),
          });
          await this.contract.fetchAbi();

          this.contractFunctions = Object.keys(this.contract.abi.methods).map(
            (name) => {
              return {
                name,
                prettyName: prettyName(name),
                readOnly: this.contract.abi.methods[name].read_only,
              };
            },
          );
        },

        /**
         * Load function details in the website
         */
        openFunction(name) {
          const { argument, description } = this.contract.abi.methods[name];
          const protobufType = argument
            ? this.contract.serializer.root.lookupType(argument)
            : undefined;

          this.contractFunction = {
            name,
            prettyName: prettyName(name),
            description,
            protobufType,
            readOnly: this.contract.abi.methods[name].read_only,
          };
          this.results = "";
        },

        /**
         * Call read function of the contract
         */
        async callReadFunction() {
          try {
            this.waitingResponse = true;
            if (!this.contractFunction) {
              throw new Error("contractFunction not defined");
            }

            // get the arguments defined by the user
            let args = {};
            if (this.contractFunction.protobufType) {
              args = this.$refs.protoMessage.getArgs();
            }
            console.log(`Calling read function '${functionName}'`);
            console.log("Arguments:");
            console.log(args);

            // execute the read function in the blockchain
            const functionName = this.contractFunction.name;
            const { result } =
              await this.contract.functions[functionName](args);
            this.results = JSON.stringify(result, null, 2);
            this.waitingResponse = false;
          } catch (error) {
            this.results = error.message;
            this.waitingResponse = false;
            throw error;
          }
        },

        /**
         * Call read function of the contract
         */
        async callWriteFunction() {
          try {
            this.waitingResponse = true;
            if (!this.contractFunction) {
              throw new Error("contractFunction not defined");
            }

            // get the arguments defined by the user
            let args = {};
            if (this.contractFunction.protobufType) {
              args = this.$refs.protoMessage.getArgs();
            }
            console.log(`Calling write function '${functionName}'`);
            console.log("Arguments:");
            console.log(args);

            // execute the write function in the blockchain
            const functionName = this.contractFunction.name;
            const { transaction } =
              await this.contract.functions[functionName](args);
            this.results = JSON.stringify(result, null, 2);
            this.waitingResponse = false;
          } catch (error) {
            this.results = error.message;
            this.waitingResponse = false;
            throw error;
          }
        },
      },
    });

    app.component("ProtoForm", ProtoForm);

    app.mount("#app");
  </script>
</html>
